# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.


@doc raw"""io.argoproj.workflow.v1alpha1.DAGTask
DAGTask represents a node in the graph during DAG execution

    IoArgoprojWorkflowV1alpha1DAGTask(;
        arguments=nothing,
        continueOn=nothing,
        dependencies=nothing,
        depends=nothing,
        hooks=nothing,
        inline=nothing,
        name=nothing,
        onExit=nothing,
        template=nothing,
        templateRef=nothing,
        when=nothing,
        withItems=nothing,
        withParam=nothing,
        withSequence=nothing,
    )

    - arguments::IoArgoprojWorkflowV1alpha1Arguments
    - continueOn::IoArgoprojWorkflowV1alpha1ContinueOn
    - dependencies::Vector{String} : Dependencies are name of other targets which this depends on
    - depends::String : Depends are name of other targets which this depends on
    - hooks::Dict{String, IoArgoprojWorkflowV1alpha1LifecycleHook} : Hooks hold the lifecycle hook which is invoked at lifecycle of task, irrespective of the success, failure, or error status of the primary task
    - inline::IoArgoprojWorkflowV1alpha1Template
    - name::String : Name is the name of the target
    - onExit::String : OnExit is a template reference which is invoked at the end of the template, irrespective of the success, failure, or error of the primary template. DEPRECATED: Use Hooks[exit].Template instead.
    - template::String : Name of template to execute
    - templateRef::IoArgoprojWorkflowV1alpha1TemplateRef
    - when::String : When is an expression in which the task should conditionally execute
    - withItems::Vector{Any} : WithItems expands a task into multiple parallel tasks from the items in the list
    - withParam::String : WithParam expands a task into multiple parallel tasks from the value in the parameter, which is expected to be a JSON list.
    - withSequence::IoArgoprojWorkflowV1alpha1Sequence
"""
Base.@kwdef mutable struct IoArgoprojWorkflowV1alpha1DAGTask <: OpenAPI.APIModel
    arguments = nothing # spec type: Union{ Nothing, IoArgoprojWorkflowV1alpha1Arguments }
    continueOn = nothing # spec type: Union{ Nothing, IoArgoprojWorkflowV1alpha1ContinueOn }
    dependencies::Union{Nothing, Vector{String}} = nothing
    depends::Union{Nothing, String} = nothing
    hooks::Union{Nothing, Dict} = nothing # spec type: Union{ Nothing, Dict{String, IoArgoprojWorkflowV1alpha1LifecycleHook} }
    inline = nothing # spec type: Union{ Nothing, IoArgoprojWorkflowV1alpha1Template }
    name::Union{Nothing, String} = nothing
    onExit::Union{Nothing, String} = nothing
    template::Union{Nothing, String} = nothing
    templateRef = nothing # spec type: Union{ Nothing, IoArgoprojWorkflowV1alpha1TemplateRef }
    when::Union{Nothing, String} = nothing
    withItems::Union{Nothing, Vector{Any}} = nothing
    withParam::Union{Nothing, String} = nothing
    withSequence = nothing # spec type: Union{ Nothing, IoArgoprojWorkflowV1alpha1Sequence }

    function IoArgoprojWorkflowV1alpha1DAGTask(arguments, continueOn, dependencies, depends, hooks, inline, name, onExit, template, templateRef, when, withItems, withParam, withSequence, )
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("arguments"), arguments)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("continueOn"), continueOn)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("dependencies"), dependencies)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("depends"), depends)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("hooks"), hooks)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("inline"), inline)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("name"), name)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("onExit"), onExit)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("template"), template)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("templateRef"), templateRef)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("when"), when)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("withItems"), withItems)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("withParam"), withParam)
        OpenAPI.validate_property(IoArgoprojWorkflowV1alpha1DAGTask, Symbol("withSequence"), withSequence)
        return new(arguments, continueOn, dependencies, depends, hooks, inline, name, onExit, template, templateRef, when, withItems, withParam, withSequence, )
    end
end # type IoArgoprojWorkflowV1alpha1DAGTask

const _property_types_IoArgoprojWorkflowV1alpha1DAGTask = Dict{Symbol,String}(Symbol("arguments")=>"IoArgoprojWorkflowV1alpha1Arguments", Symbol("continueOn")=>"IoArgoprojWorkflowV1alpha1ContinueOn", Symbol("dependencies")=>"Vector{String}", Symbol("depends")=>"String", Symbol("hooks")=>"Dict{String, IoArgoprojWorkflowV1alpha1LifecycleHook}", Symbol("inline")=>"IoArgoprojWorkflowV1alpha1Template", Symbol("name")=>"String", Symbol("onExit")=>"String", Symbol("template")=>"String", Symbol("templateRef")=>"IoArgoprojWorkflowV1alpha1TemplateRef", Symbol("when")=>"String", Symbol("withItems")=>"Vector{Any}", Symbol("withParam")=>"String", Symbol("withSequence")=>"IoArgoprojWorkflowV1alpha1Sequence", )
OpenAPI.property_type(::Type{ IoArgoprojWorkflowV1alpha1DAGTask }, name::Symbol) = Union{Nothing,eval(Base.Meta.parse(_property_types_IoArgoprojWorkflowV1alpha1DAGTask[name]))}

function check_required(o::IoArgoprojWorkflowV1alpha1DAGTask)
    o.name === nothing && (return false)
    true
end

function OpenAPI.validate_property(::Type{ IoArgoprojWorkflowV1alpha1DAGTask }, name::Symbol, val)
end
